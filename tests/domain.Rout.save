
R version 2.7.2 (2008-08-25)
Copyright (C) 2008 The R Foundation for Statistical Computing
ISBN 3-900051-07-0

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##
> ## Domain means can be written as ratio estimators or as regression coefficients
> ##
> ## This code checks that subsetting the design object gives the same results as
> ## these approaches.
> ##
> 
> 
> library(survey)

Attaching package: 'survey'


	The following object(s) are masked from package:graphics :

	 dotchart 

> data(fpc)
> dfpc<-svydesign(id=~psuid,strat=~stratid,weight=~weight,data=fpc,nest=TRUE)
> dsub<-subset(dfpc,x>4)
> (m1<-svymean(~x,design=dsub))
   mean     SE
x 6.195 0.7555
> 
> ## These should give the same domain estimates and standard errors
> (m2<-svyby(~x,~I(x>4),design=dfpc, svymean,keep.var=TRUE))
      I(x > 4)        x      se.x
FALSE    FALSE 3.314286 0.3117042
TRUE      TRUE 6.195000 0.7555129
Warning messages:
1: In onestrat(x[index, , drop = FALSE], clusters[index], nPSU[index][1],  :
  Stratum (1) has only one PSU at stage 1
2: In onestrat(x[index, , drop = FALSE], clusters[index], nPSU[index][1],  :
  Stratum (2) has only one PSU at stage 1
> m3<-svyglm(x~I(x>4)+0,design=dfpc)
> summary(m3)

Call:
svyglm(x ~ I(x > 4) + 0, design = dfpc)

Survey design:
svydesign(id = ~psuid, strat = ~stratid, weight = ~weight, data = fpc, 
    nest = TRUE)

Coefficients:
              Estimate Std. Error t value Pr(>|t|)    
I(x > 4)FALSE   3.3143     0.3117   10.63 0.000127 ***
I(x > 4)TRUE    6.1950     0.7555    8.20 0.000439 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 

(Dispersion parameter for gaussian family taken to be 2.557379)

Number of Fisher Scoring iterations: 2

> (m4<-svyratio(~I(x*(x>4)),~as.numeric(x>4), dfpc))
Ratio estimator: svyratio.survey.design2(~I(x * (x > 4)), ~as.numeric(x > 4), 
    dfpc)
Ratios=
               as.numeric(x > 4)
I(x * (x > 4))             6.195
SEs=
               as.numeric(x > 4)
I(x * (x > 4))         0.7555129
> stopifnot(isTRUE(all.equal(SE(m2), as.vector(SE(m3)))))
> stopifnot(isTRUE(all.equal(SE(m2)[2], as.vector(SE(m4)))))
> 
> ## with strata
> data(api)
> dstrat<-svydesign(id=~1, strata=~stype, weights=~pw, data=apistrat, fpc=~fpc)
> m1<-svymean(~enroll, subset(dstrat, comp.imp=="Yes"))
> m2<-svyglm(enroll~comp.imp-1, dstrat)
> m3<- svyratio(~I(enroll*(comp.imp=="Yes")), ~as.numeric(comp.imp=="Yes"), dstrat)
> stopifnot(isTRUE(all.equal(as.vector(SE(m2)["comp.impYes"]), as.vector(SE(m1)))))
> stopifnot(isTRUE( all.equal(as.vector(SE(m1)), as.vector(drop(SE(m3))))))
> 
> ## with calibration
> dclus1<-svydesign(id=~dnum, weights=~pw, data=apiclus1, fpc=~fpc)
> pop.totals<-c(`(Intercept)`=6194, stypeH=755, stypeM=1018)
> (dclus1g3 <- calibrate(dclus1, ~stype+api99, c(pop.totals, api99=3914069)))
1 - level Cluster Sampling design
With (15) clusters.
calibrate(dclus1, ~stype + api99, c(pop.totals, api99 = 3914069))
> 
> m1<-svymean(~api00, subset(dclus1g3, comp.imp=="Yes"))
> m3<-svyratio(~I(api00*(comp.imp=="Yes")), ~as.numeric(comp.imp=="Yes"), dclus1g3)
> m2<-svyglm(api00~comp.imp-1, dclus1g3)
> stopifnot(isTRUE( all.equal(as.vector(SE(m2)["comp.impYes"]), as.vector(SE(m1)))))
> stopifnot(isTRUE( all.equal(as.vector(SE(m1)), as.vector(drop(SE(m3))))))
> 
> ## with raking
> pop.types <- data.frame(stype=c("E","H","M"), Freq=c(4421,755,1018))
> pop.schwide <- data.frame(sch.wide=c("No","Yes"), Freq=c(1072,5122))
> dclus1r<-rake(dclus1, list(~stype,~sch.wide), list(pop.types, pop.schwide))
> m1<-svymean(~api00, subset(dclus1r, comp.imp=="Yes"))
> m2<-svyglm(api00~comp.imp-1, dclus1r)
> m3<-svyratio(~I(api00*(comp.imp=="Yes")), ~as.numeric(comp.imp=="Yes"), dclus1r)
> stopifnot(isTRUE( all.equal(as.vector(SE(m2)["comp.impYes"]), as.vector(SE(m1)))))
> stopifnot(isTRUE( all.equal(as.vector(SE(m1)), as.vector(drop(SE(m3))))))
> 
